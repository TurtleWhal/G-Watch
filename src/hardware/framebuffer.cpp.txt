#include "config.h"
#include "lvgl.h"
#include "framebuffer.h"
//#include "powermgm.h"
#include "utils/alloc.h"
/**
 * device depends includes and inits
 */
    #include <Arduino.h>
        #include "TFT_eSPI.h"
        //#include <twatch2021_config.h>

        TFT_eSPI tft = TFT_eSPI();

static bool framebuffer_drawing = true;                             /** @brief disable */
static bool framebuffer_use_dma = false;
lv_color_t *framebuffer_1 = NULL;                                     /** @brief pointer to a full size framebuffer */
lv_color_t *framebuffer_2 = NULL;                                     /** @brief pointer to a full size framebuffer */
uint32_t framebuffer_size = FRAMEBUFFER_BUFFER_SIZE;                /** @brief framebuffer size */

bool framebuffer_powermgm_event_cb( EventBits_t event, void *arg );
bool framebuffer_powermgm_loop_cb( EventBits_t event, void *arg );
static void framebuffer_flush_cb( lv_disp_drv_t *disp_drv, const lv_area_t *area, lv_color_t *color_p );

void framebuffer_setup( void ) {
    static lv_disp_buf_t disp_buf;
    lv_disp_drv_t disp_drv;

            framebuffer_use_dma = true;

            pinMode( TFT_LED, OUTPUT );
            ledcSetup( 0, 4000, 8 );
            ledcAttachPin( TFT_LED, 0 );
            ledcWrite( 0, 0 );

            tft.init();
            tft.fillScreen( TFT_BLACK );
            tft.initDMA();
    /*
     * allocate new framebuffer
     */
    if ( !framebuffer_1 ) {
        if ( framebuffer_use_dma ) {
            framebuffer_1 = (lv_color_t*)calloc( sizeof(lv_color_t), FRAMEBUFFER_BUFFER_W * FRAMEBUFFER_BUFFER_H );
        }
        else {
            framebuffer_1 = (lv_color_t*)CALLOC( sizeof(lv_color_t), FRAMEBUFFER_BUFFER_W * FRAMEBUFFER_BUFFER_H );
        }
        ASSERT( framebuffer_1, "framebuffer malloc failed" );
    }
    if ( !framebuffer_2 ) {
        if ( framebuffer_use_dma ) {
            framebuffer_2 = (lv_color_t*)calloc( sizeof(lv_color_t), FRAMEBUFFER_BUFFER_W * FRAMEBUFFER_BUFFER_H );
        }
        else {
            framebuffer_2 = (lv_color_t*)CALLOC( sizeof(lv_color_t), FRAMEBUFFER_BUFFER_W * FRAMEBUFFER_BUFFER_H );
        }
        ASSERT( framebuffer_2, "framebuffer malloc failed" );
    }
    /*
     * set LVGL driver
     */
    lv_disp_buf_init( &disp_buf, framebuffer_1, framebuffer_2, FRAMEBUFFER_BUFFER_W * FRAMEBUFFER_BUFFER_H );
    lv_disp_drv_init( &disp_drv );
    disp_drv.flush_cb = framebuffer_flush_cb;
    disp_drv.buffer = &disp_buf;
    disp_drv.hor_res = RES_X_MAX;
    disp_drv.ver_res = RES_Y_MAX;
    lv_disp_drv_register( &disp_drv );

    /**
     * setup powermgm events and loop
     */
    powermgm_register_cb( POWERMGM_STANDBY | POWERMGM_SILENCE_WAKEUP| POWERMGM_WAKEUP , framebuffer_powermgm_event_cb, "powermgm framebuffer" );
    powermgm_register_loop_cb( POWERMGM_SILENCE_WAKEUP | POWERMGM_STANDBY | POWERMGM_WAKEUP , framebuffer_powermgm_loop_cb, "powermgm framebuffer loop" );
}
/*
bool framebuffer_powermgm_event_cb( EventBits_t event, void *arg ) {
    switch( event ) {
        case POWERMGM_STANDBY:          log_d("go standby, refresh framebuffer");
                                        framebuffer_refresh();
                                        framebuffer_drawing = false;
                                        break;
        case POWERMGM_WAKEUP:           log_d("go wakeup");
                                        framebuffer_drawing = true;
                                        break;
        case POWERMGM_SILENCE_WAKEUP:   log_d("go wakeup");
                                        framebuffer_drawing = false;
                                        break;
    }
    return( true );
}
*/
/*
bool framebuffer_powermgm_loop_cb( EventBits_t event, void *arg ) {
    return( true );
}

void framebuffer_refresh( void ) {
}
*/

/*
static void framebuffer_flush_cb(lv_disp_drv_t *disp_drv, const lv_area_t *area, lv_color_t *color_p) {
    //if( !framebuffer_drawing )
    //        lv_disp_flush_ready( disp_drv );

             //get buffer sizs
            uint32_t size = (area->x2 - area->x1 + 1) * (area->y2 - area->y1 + 1) ;
                tft.endWrite();
                tft.startWrite();
                tft.pushImageDMA( area->x1, area->y1, (area->x2 - area->x1 + 1), (area->y2 - area->y1 + 1), ( uint16_t *)color_p );
    lv_disp_flush_ready( disp_drv );
}
*/